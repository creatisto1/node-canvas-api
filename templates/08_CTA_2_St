const { createCanvas } = require('canvas');

module.exports = async function generateTemplate_PinterestPin(quadCanvas, overlayText, website) {
  const targetWidth = 1000;
  const targetHeight = 1500;
  const canvas = createCanvas(targetWidth, targetHeight);
  const ctx = canvas.getContext('2d');

  overlayText = overlayText || 'JETZT REINSCHAUEN';
  website = website ? String(website).trim() : 'www.creatisto.com';

  // === Hintergrundfarbe ===
  ctx.fillStyle = '#FDF8F6';
  ctx.fillRect(0, 0, targetWidth, targetHeight);

  // === Quadrat-Bild oben einfügen (1000x1000) ===
  if (quadCanvas) {
    ctx.drawImage(quadCanvas, 0, 0, targetWidth, 1000);
  }

  // === Unterer farbiger Bereich mit Welle, die ins Bild ragt ===
  const waveHeight = 80;
  const colorStartY = 1000;
  const colorHeight = targetHeight - colorStartY;

  // Farbverlauf erstellen
  const gradient = ctx.createLinearGradient(0, colorStartY - waveHeight, 0, targetHeight);
  gradient.addColorStop(0, 'rgba(74,194,194,0)'); // transparent am Übergang ins Bild
  gradient.addColorStop(0.2, '#4AC2C2');
  gradient.addColorStop(1, '#4AC2C2');

  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.moveTo(0, colorStartY);
  ctx.bezierCurveTo(
    targetWidth * 0.25, colorStartY - waveHeight,
    targetWidth * 0.75, colorStartY + waveHeight,
    targetWidth, colorStartY
  );
  ctx.lineTo(targetWidth, targetHeight);
  ctx.lineTo(0, targetHeight);
  ctx.closePath();
  ctx.fill();

  // === Papierstruktur Overlay nur auf farbigem Bereich ===
  const textureCanvas = createCanvas(targetWidth, colorHeight);
  const textureCtx = textureCanvas.getContext('2d');
  textureCtx.fillStyle = 'rgba(255,255,255,0.05)';
  const points = 3000;
  for (let i = 0; i < points; i++) {
    const x = Math.random() * targetWidth;
    const y = Math.random() * colorHeight;
    const size = Math.random() * 2;
    textureCtx.fillRect(x, y, size, size);
  }
  ctx.drawImage(textureCanvas, 0, colorStartY);

  // === Textblock auf farbigem Bereich ===
  const maxTextWidth = targetWidth * 0.8;
  const maxTextBlockHeight = 200;
  const maxLines = 3;

  let chosenFontSize = 16;
  let lines = [];
  let lineHeight = 0;

  for (let size = 96; size >= 16; size -= 2) {
    ctx.font = `bold ${size}px Arial`;
    lineHeight = size * 1.3;

    const testLines = wrapText(ctx, overlayText, maxTextWidth, maxLines);
    const totalTextHeight = testLines.length * lineHeight;

    if (testLines.length <= maxLines && totalTextHeight <= maxTextBlockHeight) {
      chosenFontSize = size;
      lines = testLines;
      break;
    }
  }

  if (lines.length === 0) {
    ctx.font = `bold 16px Arial`;
    lineHeight = 16 * 1.3;
    lines = wrapText(ctx, overlayText, maxTextWidth, maxLines);
  }

  // === Overlay Text auf farbigem Bereich ===
  ctx.fillStyle = '#FFFFFF';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = `bold ${chosenFontSize}px Arial`;

  const totalTextHeight = lines.length * lineHeight;
  const startY = colorStartY + 40;

  lines.forEach((line, index) => {
    ctx.fillText(line, targetWidth / 2, startY + index * lineHeight);
  });

  // === Button auf farbigem Bereich ===
  const buttonText = 'MEHR ERFAHREN';
  const buttonFontSize = Math.floor(targetHeight * 0.035);
  const buttonPaddingX = 40;
  const buttonPaddingY = 20;

  ctx.font = `bold ${buttonFontSize}px Arial`;
  const textWidth = ctx.measureText(buttonText).width;
  const buttonWidth = textWidth + buttonPaddingX * 2;
  const buttonHeight = buttonFontSize + buttonPaddingY * 2;
  const buttonX = targetWidth / 2 - buttonWidth / 2;
  const buttonY = startY + totalTextHeight + 40;

  ctx.fillStyle = '#2C9C9C';
  ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

  ctx.fillStyle = '#FFFFFF';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(buttonText, targetWidth / 2, buttonY + buttonHeight / 2);

  // === URL unter dem Button ===
  const urlFontSize = 43;
  ctx.font = `bold ${urlFontSize}px Arial`;
  ctx.fillStyle = '#FFFFFF';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  const urlY = buttonY + buttonHeight + 12;
  ctx.fillText(website, targetWidth / 2, urlY);

  return canvas;
};

// === Hilfsfunktionen ===
function wrapText(ctx, text, maxWidth, maxLines) {
  const words = text.split(' ');
  let lines = [];
  let currentLine = '';

  for (let word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const testWidth = ctx.measureText(testLine).width;

    if (testWidth <= maxWidth) {
      currentLine = testLine;
    } else {
      lines.push(currentLine);
      currentLine = word;
      if (lines.length >= maxLines) break;
    }
  }
  if (currentLine && lines.length < maxLines) lines.push(currentLine);
  return lines;
}
