const { createCanvas } = require('canvas');

/**
 * Generiert ein Pinterest-Pin-Canvas für DIY mit harmonischen Wellen
 * Overlay-Text und Button sitzen nun unterhalb der Wellen
 */
module.exports = function generateTemplate_PinterestDIY(quadCanvas, overlayText, website) {
  const targetWidth = 1000;
  const targetHeight = 1500;
  const canvas = createCanvas(targetWidth, targetHeight);
  const ctx = canvas.getContext('2d');

  overlayText = overlayText ? String(overlayText).trim() : 'JETZT REINSCHAUEN';
  website = website ? String(website).trim() : 'www.creatisto.com';

  // === Hintergrundfarbe ===
  ctx.fillStyle = '#FFF1E6';
  ctx.fillRect(0, 0, targetWidth, targetHeight);

  // === Quadrat-Bild oben einfügen ===
  if (quadCanvas) {
    try {
      ctx.drawImage(quadCanvas, 0, 0, targetWidth, 1000);
    } catch (e) {
      console.warn('quadCanvas konnte nicht gezeichnet werden:', e.message);
    }
  }

  // === Harmonische Wellen über dem farbigen Bereich ===
  const baseWaveHeight = 80 * 1.08 * 0.3 * 0.5; // amplitude 50% niedriger
  const colorStartY = 1000;
  const colorHeight = targetHeight - colorStartY;

  const gradient = ctx.createLinearGradient(0, colorStartY, 0, targetHeight);
  gradient.addColorStop(0, '#a2d5c6');
  gradient.addColorStop(1, '#077b8a');

  ctx.beginPath();
  const waveCount = 5;
  ctx.moveTo(0, colorStartY);

  for (let x = 0; x <= targetWidth; x++) {
    const y = colorStartY + Math.sin((x / targetWidth) * waveCount * Math.PI * 2) * baseWaveHeight;
    ctx.lineTo(x, y);
  }

  ctx.lineTo(targetWidth, targetHeight);
  ctx.lineTo(0, targetHeight);
  ctx.closePath();
  ctx.fillStyle = gradient;
  ctx.fill();

  // === Papierstruktur auf dem farbigen Bereich ===
  const textureCanvas = createCanvas(targetWidth, colorHeight);
  const textureCtx = textureCanvas.getContext('2d');
  textureCtx.fillStyle = 'rgba(255,255,255,0.05)';
  for (let i = 0; i < 3000; i++) {
    const x = Math.random() * targetWidth;
    const y = Math.random() * colorHeight;
    const size = Math.random() * 2;
    textureCtx.fillRect(x, y, size, size);
  }

  ctx.save();
  ctx.clip();
  ctx.drawImage(textureCanvas, 0, colorStartY);
  ctx.restore();

  // === Overlay-Text unterhalb der Wellen (dynamisch) ===
  const maxTextWidth = targetWidth * 0.8;
  const maxTextBlockHeight = 200;
  const maxLines = 3;
  let chosenFontSize = 16;
  let lines = [];
  let lineHeight = 0;

  for (let size = 96; size >= 16; size -= 2) {
    ctx.font = `bold ${size}px "Arial", sans-serif`;
    lineHeight = size * 1.25;
    const testLines = wrapText(ctx, overlayText, maxTextWidth, maxLines);
    const totalTextHeight = testLines.length * lineHeight;
    if (testLines.length <= maxLines && totalTextHeight <= maxTextBlockHeight) {
      chosenFontSize = size;
      lines = testLines;
      break;
    }
  }
  if (lines.length === 0) {
    ctx.font = `bold ${chosenFontSize}px "Arial", sans-serif`;
    lineHeight = chosenFontSize * 1.25;
    lines = wrapText(ctx, overlayText, maxTextWidth, maxLines);
  }

  ctx.fillStyle = '#FFFFFF'; // Text weiß
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = `bold ${chosenFontSize}px "Arial", sans-serif`;

  const totalTextHeight = lines.length * lineHeight;
  const startY = colorStartY + baseWaveHeight + 20; // direkt unterhalb der Wellen

  lines.forEach((line, index) => {
    ctx.fillText(line, targetWidth / 2, startY + index * lineHeight);
  });

  // === Button DIY unterhalb des Overlay-Texts ===
  const buttonText = 'Do it Yourself';
  const buttonFontSize = Math.max(14, Math.floor(targetHeight * 0.035 * 1.1)); // 10% größer
  const buttonPaddingX = 40;
  const buttonPaddingY = 20;

  ctx.font = `bold ${buttonFontSize}px "Arial", sans-serif`;
  const textWidth = ctx.measureText(buttonText).width;
  const buttonWidth = textWidth + buttonPaddingX * 2;
  const buttonHeight = buttonFontSize + buttonPaddingY * 2;
  const buttonX = targetWidth / 2 - buttonWidth / 2;
  const buttonY = startY + totalTextHeight + 50; // dynamisch unter Text

  roundRect(ctx, buttonX, buttonY, buttonWidth, buttonHeight, 8);
  ctx.fillStyle = '#05575b'; // dunklerer Button
  ctx.fill();

  ctx.fillStyle = '#FFFFFF'; // Button-Text
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(buttonText, targetWidth / 2, buttonY + buttonHeight / 2);

  // === URL oben auf dem Bild mit weißem Hintergrund ===
  let urlFontSize = 43 * 1.1 * 1.1; // größer
  ctx.font = `bold ${urlFontSize}px "Arial", sans-serif`;
  const urlWidth = ctx.measureText(website).width + 30;
  const urlHeight = urlFontSize + 20;
  const urlX = targetWidth / 2 - urlWidth / 2;
  const urlY = 100;

  ctx.fillStyle = '#FFFFFF';
  roundRect(ctx, urlX, urlY, urlWidth, urlHeight, 8);
  ctx.fill();

  ctx.fillStyle = '#333333'; // dunkelgrau
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(website, targetWidth / 2, urlY + urlHeight / 2);

  return canvas;
};

// ===== Hilfsfunktionen =====
function wrapText(ctx, text, maxWidth, maxLines) {
  const words = String(text).split(/\s+/);
  const lines = [];
  let current = '';

  for (let w = 0; w < words.length; w++) {
    const word = words[w];
    const test = current ? `${current} ${word}` : word;
    if (ctx.measureText(test).width <= maxWidth) {
      current = test;
      continue;
    }
    if (current) {
      lines.push(current);
      current = '';
      if (lines.length >= maxLines) break;
    }
    if (ctx.measureText(word).width > maxWidth) {
      let part = '';
      for (let i = 0; i < word.length; i++) {
        part += word[i];
        if (ctx.measureText(part + (i < word.length - 1 ? '-' : '')).width > maxWidth) {
          const pushPart = part.slice(0, -1);
          if (pushPart) lines.push(pushPart + '-');
          part = word[i];
          if (lines.length >= maxLines) break;
        }
      }
      if (part && lines.length < maxLines) current = part;
    } else {
      if (lines.length < maxLines) current = word;
    }
  }
  if (current && lines.length < maxLines) lines.push(current);
  return lines.slice(0, maxLines);
}

function roundRect(ctx, x, y, width, height, radius) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + width, y, x + width, y + height, radius);
  ctx.arcTo(x + width, y + height, x, y + height, radius);
  ctx.arcTo(x, y + height, x, y, radius);
  ctx.arcTo(x, y, x + width, y, radius);
  ctx.closePath();
}
