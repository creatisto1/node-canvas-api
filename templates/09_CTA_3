const { createCanvas } = require('canvas');

module.exports = function generateTemplate_DIYPin(quadCanvas, overlayText, website) {
  const targetWidth = 1000;
  const targetHeight = 1500;
  const canvas = createCanvas(targetWidth, targetHeight);
  const ctx = canvas.getContext('2d');

  overlayText = overlayText ? String(overlayText).trim() : '';
  website = website ? String(website).trim() : 'www.creatisto.com';

  const barHeight = 100; // Höhe des Balkens oben
  const beigeColor = '#F5F0E6'; // helles Beige

  // === Hintergrundfarbe ===
  ctx.fillStyle = '#FDF8F6';
  ctx.fillRect(0, 0, targetWidth, targetHeight);

  // === Durchgehender Balken oben ===
  ctx.fillStyle = beigeColor;
  ctx.fillRect(0, 0, targetWidth, barHeight);

  // === URL-Text im Balken ===
  const urlFontSize = 50; // größere Schrift
  ctx.font = `bold ${urlFontSize}px "Arial", sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#333333'; // dunkle Schrift für Kontrast
  ctx.fillText(website, targetWidth / 2, barHeight / 2);

  // === Quadrat-Bild oben einfügen (1000x1000), direkt unter Balken ===
  if (quadCanvas) {
    try {
      ctx.drawImage(quadCanvas, 0, barHeight, targetWidth, 1000);
    } catch (e) {
      console.warn('quadCanvas konnte nicht gezeichnet werden:', e.message);
    }
  }

  // === Untere farbige Fläche (Beige) ===
  const lowerY = barHeight + 1000; // direkt unter dem Bild
  const lowerHeight = targetHeight - lowerY;
  ctx.fillStyle = beigeColor;
  ctx.fillRect(0, lowerY, targetWidth, lowerHeight);

  // === Overlay Text + Button ===
  const maxTextWidth = targetWidth * 0.8;
  const maxTextBlockHeight = 200;
  const maxLines = 3;

  // Schriftgrößenbereich
  const maxFont = 96;
  const minFont = 12; // kannst du anpassen
  let chosenFontSize = minFont;
  let lines = [];
  let lineHeight = 0;

  if (overlayText) {
    // Versuche von groß nach klein eine passende Schriftgröße zu finden
    for (let size = maxFont; size >= minFont; size -= 1) {
      ctx.font = `bold ${size}px "Arial", sans-serif`;
      lineHeight = Math.ceil(size * 1.2); // Zeilenhöhe (1.2)
      const testLines = wrapText(ctx, overlayText, maxTextWidth, maxLines);
      const totalTextHeight = testLines.length * lineHeight;

      if (testLines.length <= maxLines && totalTextHeight <= maxTextBlockHeight) {
        chosenFontSize = size;
        lines = testLines;
        break;
      }
    }

    // Falls keine Größe gefunden wurde (selbst minFont passt nicht), dann:
    if (lines.length === 0) {
      chosenFontSize = minFont;
      ctx.font = `bold ${chosenFontSize}px "Arial", sans-serif`;
      lineHeight = Math.ceil(chosenFontSize * 1.2);
      lines = wrapText(ctx, overlayText, maxTextWidth, maxLines);

      // Wenn noch mehr als maxLines vorhanden sind, ellipsize die letzte Zeile.
      if (lines.length > maxLines) {
        lines = lines.slice(0, maxLines);
      }
      // Sorge dafür, dass letzte Zeile ggf. gekürzt wird, falls sie noch zu breit ist.
      if (lines.length > 0) {
        lines[lines.length - 1] = ellipsizeLine(ctx, lines[lines.length - 1], maxTextWidth);
      }
    }

    // === Overlay Text zeichnen ===
    ctx.fillStyle = '#333333';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = `bold ${chosenFontSize}px "Arial", sans-serif`;

    const totalTextHeight = lines.length * lineHeight;
    const paddingTop = 20;
    const startY = lowerY + paddingTop;

    // Wenn der Text block (inkl. Button) zu groß für den unteren Bereich ist, 
    // verkleinere ggf. chosenFontSize noch weiter (fallback) — aber in der Regel schon erledigt.
    const buttonGap = 30;
    const estimatedButtonHeight = Math.max(36, Math.floor(targetHeight * 0.035)); // grobe Schätzung
    const neededHeight = totalTextHeight + buttonGap + estimatedButtonHeight + paddingTop;
    if (neededHeight > lowerHeight) {
      // Berechne um wieviel wir noch schrumpfen müssen (iterativ)
      for (let size = chosenFontSize - 1; size >= minFont; size--) {
        ctx.font = `bold ${size}px "Arial", sans-serif`;
        lineHeight = Math.ceil(size * 1.2);
        const testLines = wrapText(ctx, overlayText, maxTextWidth, maxLines);
        const testTotal = testLines.length * lineHeight + buttonGap + estimatedButtonHeight + paddingTop;
        if (testLines.length <= maxLines && testTotal <= lowerHeight) {
          chosenFontSize = size;
          lines = testLines;
          break;
        }
      }
      // Wenn nach diesem Schritt immer noch overflow, ellipsize letzte Zeile:
      if (lines.length > maxLines) lines = lines.slice(0, maxLines);
      if (lines.length > 0) lines[lines.length - 1] = ellipsizeLine(ctx, lines[lines.length - 1], maxTextWidth);
      ctx.font = `bold ${chosenFontSize}px "Arial", sans-serif`;
      lineHeight = Math.ceil(chosenFontSize * 1.2);
    }

    // Zeichnen der Textzeilen
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], targetWidth / 2, startY + i * lineHeight);
    }

    // === Button "JETZT ENTDECKEN" ===
    const scale = 0.92; // 8% kleiner
    const buttonText = 'JETZT ENTDECKEN';
    let buttonFontSize = Math.max(14, Math.floor(targetHeight * 0.035 * 1.1));
    buttonFontSize = Math.floor(buttonFontSize * scale);

    const buttonPaddingX = 40 * scale;
    const buttonPaddingY = 14 * scale;

    ctx.font = `bold ${buttonFontSize}px "Arial", sans-serif`;
    const textWidth = ctx.measureText(buttonText).width;
    const buttonWidth = textWidth + buttonPaddingX * 2;
    const buttonHeight = buttonFontSize + buttonPaddingY * 2;

    // Button-Position: unterhalb des Textblocks, mit Abstand
    const buttonX = targetWidth / 2 - buttonWidth / 2;
    const buttonY = startY + lines.length * lineHeight + 20;

    // Falls Button über das untere Ende hinausragt, verschiebe ihn nach oben so viel wie möglich
    let finalButtonY = buttonY;
    const bottomPadding = 12;
    if (finalButtonY + buttonHeight + bottomPadding > targetHeight) {
      finalButtonY = targetHeight - bottomPadding - buttonHeight;
    }

    roundRect(ctx, buttonX, finalButtonY, buttonWidth, buttonHeight, 8);
    ctx.fillStyle = '#C0A880';
    ctx.fill();

    ctx.fillStyle = '#FFFFFF';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(buttonText, targetWidth / 2, finalButtonY + buttonHeight / 2);
  }

  return canvas;
};

// ===== Hilfsfunktionen =====
function wrapText(ctx, text, maxWidth, maxLines) {
  // Wrappt Text basierend auf aktueller ctx.font, bricht Wortgruppen wenn nötig (mit Bindestrich).
  const words = String(text).split(/\s+/);
  const lines = [];
  let current = '';

  for (let w = 0; w < words.length; w++) {
    const word = words[w];
    const test = current ? `${current} ${word}` : word;
    if (ctx.measureText(test).width <= maxWidth) {
      current = test;
      continue;
    }

    if (current) {
      lines.push(current);
      current = '';
      if (lines.length >= maxLines) break;
    }

    // falls ein einzelnes Wort breiter als maxWidth ist -> weise Teilstücke zu (Hyphenation)
    if (ctx.measureText(word).width > maxWidth) {
      let part = '';
      for (let i = 0; i < word.length; i++) {
        part += word[i];
        // Falls das Part zu breit wird, push vorheriges part (ohne letztes Zeichen)
        if (ctx.measureText(part + (i < word.length - 1 ? '-' : '')).width > maxWidth) {
          const pushPart = part.slice(0, -1);
          if (pushPart) {
            lines.push(pushPart + '-');
            if (lines.length >= maxLines) break;
          }
          part = word[i];
        }
      }
      if (lines.length >= maxLines) break;
      // Das verbleibende 'part' soll als aktuelles beginnen (falls noch platz für weitere Wortreste)
      if (part) current = part;
    } else {
      if (lines.length < maxLines) current = word;
    }
  }

  if (current && lines.length < maxLines) lines.push(current);
  return lines.slice(0, maxLines);
}

function ellipsizeLine(ctx, line, maxWidth) {
  // Falls die Zeile zu breit ist, schneidet diese Funktion Zeichen ab und hängt '…' an.
  if (ctx.measureText(line).width <= maxWidth) return line;
  const ell = '…';
  let low = 0;
  let high = line.length;
  // Binary search für die richtige Länge
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    const test = line.slice(0, mid) + ell;
    if (ctx.measureText(test).width <= maxWidth) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return line.slice(0, Math.max(0, low - 1)) + ell;
}

function roundRect(ctx, x, y, width, height, radius) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + width, y, x + width, y + height, radius);
  ctx.arcTo(x + width, y + height, x, y + height, radius);
  ctx.arcTo(x, y + height, x, y, radius);
  ctx.arcTo(x, y, x + width, y, radius);
  ctx.closePath();
}
